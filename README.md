# Directory Consolidator

![License: MIT](https://img.shields.io/badge/License-MIT-green.svg)

Консольное приложение, которое объединяет содержимое произвольного числа исходных папок (от 1 до 100 000) в одну итоговую директорию, гарантируя отсутствие дубликатов (сравнение по SHA-256) и пустых папок.

## Требования

- Python 3.10+

## Установка

```bash
python -m venv .venv
source .venv/bin/activate  # в PowerShell: .venv\Scripts\Activate.ps1
pip install -U pip
pip install .
```

## Запуск

```bash
python -m consolidator.app
# или
dir-consolidator
```

Во время запуска приложение:

1. Запрашивает пути к исходным папкам по одному (пустая строка завершает ввод). Допустимо от 1 до 100 000 директорий.
2. Показывает прогресс хэширования/копирования и лог с именами файлов.
3. Хэширует файлы, копирует только одну версию на каждый SHA-256 (даже если исходные имена разные), дубликаты логирует и пропускает; при конфликте путей добавляет датовый модификатор сразу после имени (формат `filename.ext__YYMMDD[-HH][-MM][-SS][_#]`, с автопереходом к `YYYYMMDD`, если встречается другое столетие).
4. Удаляет пустые подпапки в результате и выводит агрегированную статистику.

## Примечания

- Папка результата не должна лежать внутри одной из исходных, и наоборот; вложенные комбинации блокируются заранее.
- Перед стартом инструмент проверяет, что целевая папка пуста: можно выбрать пустую директорию или подтвердить её автоматическую очистку прямо в консоли.
- Если путь результата ещё не существует, он будет создан автоматически.
- При совпадении относительных путей, но различном содержимом файл получает модификатор на основе времени изменения: к оригинальному имени и расширению добавляется `__YYMMDD`, при конфликтах столетий — `__YYYYMMDD`, далее `-HH`, `-MM`, `-SS`, а затем при необходимости счётчик. Время берётся в UTC, чтобы имена были однозначными между средами.
- Если исходное имя содержит слово `copy`, утилита предпочитает вариант без него (например, `report copy.txt` → `report.txt`) и лишь затем добавляет датовый суффикс.
- Если встречаются файлы с идентичным содержимым, в результате остаётся версия с самым длинным «очищенным» именем (после удаления `copy`, без учёта регистра); если более подходящее имя встретится позже, существующий файл автоматически переименуется.
- После копирования инструмент автоматически удаляет системные файлы macOS (`.DS_Store`, `.localized`), чтобы не оставались пустые каталоги, созданные Finder.
- Все операции над файлами выполняются с до 5 повторных попыток; если путь так и не удаётся прочитать/скопировать, он попадает в `consolidator_errors.log`, но консолидация продолжается по остальным папкам.
- Файл `consolidator_errors.log` создаётся при каждом запуске: если ошибок нет, в нём будет только заголовок, иначе — подробности по каждому недоступному пути.
- Unicode-имена поддерживаются без переименования.

Пример содержимого `consolidator_errors.log`:

```text
timestamp	action	path	error
Ошибок не обнаружено
```

Если ошибки есть:

```text
timestamp	action	path	error
2024-11-10T12:34:56+00:00	read	/Volumes/source/secret	PermissionError(13, 'Permission denied')
```

Контрольный хэш результирующей структуры:

- **Linux/GNU find** (единообразный порядок файлов):
  ```bash
  LC_ALL=C find result -type f -printf '%P\0' | sort -z | xargs -0 shasum -a 256 | shasum -a 256
  ```
- **macOS/BSD find** (без `-printf`):
  ```bash
  LC_ALL=C find result -type f -print0 | sort -z | xargs -0 shasum -a 256 | shasum -a 256
  ```
Используйте тот же вариант команды, что и в эталоне, иначе контрольный хэш может не совпасть из-за разного порядка файлов. Дополнительные сценарии и фактические логи описаны в `docs/testing.md`.

## Проверка точности

Для оперативного контроля метрики точности запустите smoke-тест:

```bash
python scripts/smoke_accuracy.py
```

Сценарий поднимает временные исходники (в том числе три и более папок), прогоняет консолидацию, проверяет удаление артефактов Finder, корректность датовых модификаторов, отсутствие «copy» в именах, а также то, что в результирующем наборе остаётся только одна копия на каждый SHA-256. Любое расхождение или появление пустых директорий приводит к выходу с ненулевым кодом.

**Быстрый smoke-старт**

```bash
python -m venv .venv
source .venv/bin/activate
pip install -U pip
pip install .
python scripts/smoke_accuracy.py
```

Этого набора команд достаточно, чтобы поднять чистое окружение, установить зависимости и подтвердить корректность пайплайна перед реальным запуском.
Для короткого прогона можно свернуть всё в цепочку `python -m venv .venv && source .venv/bin/activate && pip install . && python scripts/smoke_accuracy.py`.

## Сборка standalone-бинаря (macOS)

Для офлайн-доставки можно собрать единые исполняемые файлы PyInstaller.

**arm64 (текущая среда):**

```bash
source .venv/bin/activate
pip install pyinstaller  # однократно
scripts/build_executable.sh
./dist/macos-arm64/dir-consolidator
```

Скрипт удаляет старые артефакты конкретного таргета и складывает бинарь в `dist/macos-<архитектура>/dir-consolidator`. Первые подсказки в CLI идентичны обычному запуску.

**x86_64 (Rosetta):**

1. Поставьте universal2 Python 3.10 с python.org и Rosetta (`softwareupdate --install-rosetta`).
2. Создайте отдельное окружение:  
   `arch -x86_64 /Library/Frameworks/Python.framework/Versions/3.10/bin/python3 -m venv .venv-x86`
3. Активируйте его через `arch -x86_64 zsh` → `source .venv-x86/bin/activate`, установите `pip install -U pip && pip install . pyinstaller`.
4. Соберите бинарь:  
   `ARCH=x86_64 VENV_BIN="$PWD/.venv-x86/bin" scripts/build_executable.sh`

Получится `dist/macos-x86_64/dir-consolidator`.

**Universal 2 (совмещённый):**

```bash
lipo -create \
  dist/macos-arm64/dir-consolidator \
  dist/macos-x86_64/dir-consolidator \
  -output dist/dir-consolidator-universal
```

После этого `dist/dir-consolidator-universal` содержит оба арх-лейаута и подходит для распространения без требований к типу процессора.

Дополнительные материалы по позиционированию и листингу возможностей находятся в `marketingdocs/directory_consolidator_page.md` и `marketingdocs/feature_list.md` — README дублирует только ключевые команды, чтобы инструкции не расходились.

## PyInstaller артефакты (15 ноября 2025)

| Сборка | Бинарь | SHA-256 | Smoke-лог |
| --- | --- | --- | --- |
| arm64 (macOS 15.5, Python 3.10.19) | `dist/macos-arm64/dir-consolidator` | `71ef5ad73f1b80c993ed960a26174d4b6c455a3d325011a008646e7d421b7b00` | `docs/smoke_runs/2025-11-15-arm64.txt` |
| x86_64 (macOS 15.5 + Rosetta, Python 3.10.11) | `dist/macos-x86_64/dir-consolidator` | `bd55b89686e80fee6deb36e2ebe48f6c2fe283ebbc6274753ceca85d49a06407` | `docs/smoke_runs/2025-11-15-x86_64.txt` |
| Universal2 (lipo arm64+x86_64) | `dist/dir-consolidator-universal` | `480e7429add233a706df321d6f1e15e5196616b6aaaa37938b131c79d2a19c59` | Использует те же smoke-прогоны, что и отдельные архитектуры |

Каждая строчка подтверждена PyInstaller-сборкой соответствующего виртуального окружения и запуском `scripts/smoke_accuracy.py`. Если потребуется перепроверить целостность перед выдачей клиентам, сравните SHA-256 с опубликованным значением и приложите соответствующий лог из `docs/smoke_runs/`.

## Лицензия

Проект распространяется по [MIT License](LICENSE). Добавление бейджа в заголовке и наличие файла LICENSE синхронизируют README с релизным чек-листом и позволяют зримо подтвердить статус открытого исходного кода.
